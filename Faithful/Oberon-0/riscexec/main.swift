//
//  main.swift
//  riscexec
//
//  Created by Chip Jarred on 10/22/19.
//  Copyright Â© 2019 Chip Jarred. All rights reserved.
//

import Foundation

import Oberon
import Texts
import RISC
import OSP

// ---------------------------------------------------
fileprivate func Help()
{
	let helpStr =
	"""
	RISC Binary Runner v1.0

	Usage: riscexec filename.risc

	Executes a binary generated by oberonc in Oberon's RISC emulator.
	"""

	print(helpStr)
}

// ---------------------------------------------------
/*
- FIXME: This argument processing is pretty lame.  We don't check file
extensions, for example.  We also don't use the "+" suffixes (which for a Unixy
world, really should be a command line option.
*/
if CommandLine.argc != 2 {
	Help()
}
else
{
	let binaryName = CommandLine.arguments[1]
	
	guard let codeData = try? Data(contentsOf: URL(fileURLWithPath: binaryName))
	else
	{
		print("Unable to read file, \(binaryName)")
		exit(-1)
	}
	
	guard codeData.count % MemoryLayout<LONGINT>.size == 0 else
	{
		print("\(binaryName) has improper length to be a RISC binary")
		exit(-1)
	}
	
	var code = ARRAY<LONGINT>(contentsOf: codeData)
	guard code[0] == OSP.magic else {
		print("Invalid program signature.  Aborting...")
		exit(-1)
	}
	let entry = code[1]
	code.removeFirst(2) // Strip off magic and entry point entries
	RISC.Load(code, LONGINT(code.count))
	
	print("\(binaryName) loaded.")
	
	var scanner = Texts.Scanner()
	
	// Passing nil for the Text in OpenScanner sets the Scanner/Reader's
	// Text to nil, which is hacked to causes it to read from stdin.
	Texts.OpenScanner(&scanner, nil, 0)

	// Passing nil for the output text to RISC.Execute triggers my hack
	// for it to write to stdout.
	RISC.Execute(entry, &scanner, nil)
}

exit(0)
