#  Oberon-0 Compiler with Abstract Syntax Tree
## Motivation
Having translated the Oberon-0 compiler into Swift and refactored it into something readable, the next logical step seems to be the introduction of an abstract syntax tree (AST), a staple of compilers that is completely missing from Wirth's code.   An AST enables opportunities for doing better type checking, semantic analysis, and optimization, not to mention, as proven by Clang libtooling, allows for other tools that hook into the AST, like linters, refactoring, etc...  The version of the Oberon-0 compiler in this directory seeks to alter the compiler so that it generates an AST, moving type checking and RISC code generation to separate phases using the Oberon-0-Swift version as its starting point.

## Status: Done
I have implemented the AST-generating parser, the type checker, and the code generator, and compiler object to drive them. `NewParser.swift` contains the new parser and will eventually replace and be renamed to `Parser.swift` once I get this version all the way to the point of code generation.  `TypeChecker.swift` contains, as its name suggets, the type checker.  `CodeGenerator.swift`, of course, is the code generator, but it uses `RISCCodeGenerator.swift` which is little changed from the `Oberon-0-Swift` version of the compiler. `Compiler.swift` contains the compiler object that uses the other components.

These new components are written with unit testing in mind, and so there are many more unit tests for them than for earlier versions; however, I don't currently have tests for diagnostic messages, which ideally one would do for a real compiler (ie.  test not only that it can compile a correct, well-formed program, but that it properly rejects incorrect ones ).  

While I have significantly improved diagnostic messages over previous versions, they still really suck.   The original only emitted an offset into the source file and an error messages that was often just one word and a question mark. I had already improved that a bit in the `Oberon-0-Swift` version, emitting more informative messages that include name the source file name with line and column numbers (each tab counts as 1 column, though, so using them for indentation can make the error messages less clear).   Ideally the error message would include the offending source code fragment in context, marking the location in a visual way, so you wouldn't have to count out characters on the line to find out where the problem is.  Also some modern compilers attempt to make guesses for what the programmer was trying to do and offer suggestions, even providing "fix-its".   I view those enhancements as being out-of-scope for a compiler that's intended for instructional use.  The point is just to illustrate compiler basics in a clear way.

The `TypeChecker` does do type checking as its name suggests, but it does more than that.  It handles symbol declartions, which are actually needed for type checking.  It also performs one task that is often lumped in with optimizations: constant folding.  While optimizations are generally performed later, constant folding can be done early, and doing so has some benefits for symbol definition and type checking.  It allows identification of identical types such as arrays that might have been declared using different constant expressions for their sizes, but that evaluate to be the same size.  Such types would not appear to be the same during the type checking pass, if constant folding weren't also being done at that stage.  Additionally it can be used to simplify the AST for expressions, even if the expression as a whole isn't constant.  For example, `x & (z = (y * 2 + 1))`  can be replaced with just `x`, if `y` and `z` are constants and the equality test evaluates to `TRUE`.  

The `CodeGenerator` emits code using the same `RISCCodeGenerator` used by the original compiler.  Whereas `RISCCodeGenerator` is essentially a collection of routines to emit instructions for various language tasks (calling procedures, assigning values to variables, etc...), but doesn't itself understand the program structure for which it is emitting instructions,  `CodeGenerator` walks the type-checked AST, sending requests to the `RISCCodeGenerator` to emit instructions according to the program structure.   `CodeGenerator` is perhaps still a bit too tied to the specific RISC architecture to allow targeting a new platform without some changes to it; however, one could, in theory, replace `RISCCodeGenerator` with another platform-specific code generator to emit instructions for a different platform.  It is, of course, tied to the specific AST generated by the Oberon-0 parser, but one could even replace that with a parser for a different language, so long as it generate a valid AST as recognized by the `CodeGenerator`.  Essentially a lot of decoupling as been achieved between front-end language and back-end code generation to allow for someone to replace one or the other.

There is also now a `Compiler.swift` component that is the driver for the others.  It takes source code as input and emits both the executable binary (for the RISC emulator), and a disassembly.

`oberonc` now uses the AST-generating `Compiler` object to compile source code.  It also now enforces compiling only a single source file.  While previous versions would compile multiple source files, only the last one actually produced useful output anyway, since there is no mechanism for linking modules, nor does Oberon-0 support inter-module references.

`riscexec` works just like it always has, relying on the `RISCEmulator` class, which has not changed since the `Oberon-0-Swift` version.
