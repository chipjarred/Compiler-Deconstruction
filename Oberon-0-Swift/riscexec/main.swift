//
//  main.swift
//  riscexec
//
//  Created by Chip Jarred on 10/22/19.
//  Copyright Â© 2019 Chip Jarred. All rights reserved.
//

import Foundation

// ---------------------------------------------------
fileprivate func Help()
{
	let helpStr =
	"""
	RISC Binary Runner v1.0

	Usage: riscexec filename.risc

	Executes a binary generated by oberonc in Oberon's RISC emulator.
	"""

	print(helpStr)
}

// ---------------------------------------------------
/*
- FIXME: This argument processing is pretty lame.  We don't check file
extensions, for example.  We also don't use the "+" suffixes (which for a Unixy
world, really should be a command line option.
*/
if CommandLine.argc != 2 {
	Help()
}
else
{
	let binaryName = CommandLine.arguments[1]
	
	guard let codeData = try? Data(contentsOf: URL(fileURLWithPath: binaryName))
	else
	{
		print("Unable to read file, \(binaryName)")
		exit(-1)
	}
	
	guard codeData.count % MemoryLayout<Int>.size == 0 else
	{
		print("\(binaryName) has improper length to be a RISC binary")
		exit(-1)
	}
	
	var code = codeData.withUnsafeBytes {
		return [UInt32]($0.bindMemory(to: UInt32.self))
	}
	guard code[0] == OSP.magic else {
		print("Invalid program signature.  Aborting...")
		exit(-1)
	}
	let entry = code[1]
	code.removeFirst(2) // Strip off magic and entry point entries
	RISC.load(code, Int(code.count))
	
	print("\(binaryName) loaded.")
	
	// Passing nil for the output text to RISC.Execute triggers my hack
	// for it to write to stdout.
	var scanner = RISCInputScanner()
	RISC.execute(entry, input: &scanner)
}

exit(0)
